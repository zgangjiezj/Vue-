## 1. vue单文件组件
    <template>
      <div>xxx</div>
    </template>
    <script>
      export default {
        props: []/{}
        data(){},
        computed: {}
        methods: {},
        watch: {}
        filters: {}
        directives: {}
        components: {}
      }
    </script>
    <style scoped>
    </style>
  ****import引入，components注册，<App/>使用
  一般组件的使用：
        ****import引入，components注册，<App/>使用
        import Blog from './Blog'
        components: { // 注册局部组件, 只能在当前组件使用 ==》也可注册全局组件
            Blog
            }
        <Blog/>
        
## 2. 组件化编码的基本流程
    1). 拆分界面, 抽取组件
    2). 编写静态组件
    3). 编写动态组件
            初始化数据, 动态显示初始化界面
            实现与用户交互功能

    设计data
        类型: [{id: 1, title: 'xxx', completed: false}]
        名称: todos
        位置: 如果只是哪个组件用, 交给它; 如果是哪些组件用, 交给共同的父组件
    
    关于状态数据的更新
        data数据定义在哪个组件, 更新数据的行为就定义在哪个组件
        如果子组件要更新父组件的数据, 调用父组件的更新函数来更新父组件的数据
        一个组件接收属性数据不要直接修改, 只是用来读取显示的

    自己加的：关于data更新等的变化的方法：是数组==》用处理数组的原生的方法来添加，删除......


例：search页面，main页面 ===》搜索GitHub用户的例子
   main页面中：data中的状态来确定，main页面有四种页面的展示

   一个组件中，根据具体情况显示多种页面 ===解决办法：data和v-if/v-else-if/v-else 共同完成
   组件间通信：
      全局事件总线：index.js中挂载到propotery
                   search.vue==>在search按钮的search()方法中===》分发事件
                   main.vue:==>在mouted中 ,绑定事件监听：分发事件中分发了啥参数，监听的回调函数中就接啥参数
                               在监听的回调函数中发axios请求：在成功或失败的回调中，根据显示的不同页面更改data中的状态


*****提供数据：data 、computed、props
## 3. 组件间通信
    1). 组件通信的5种方式
        props
        vue的自定义事件
        全局事件总线
        slot
        vuex(后面单独讲)
    2). props: 标签属性
        父子组件间通信的基本方式
        属性值的2大类型:
            一般/非函数: 父组件-->子组件
            函数: 子组件-->父组件 ,父组件定义函数，子组件调用函数传参，父组件接收数据
        问题: 
            隔层组件间传递: 必须逐层多级传递(麻烦)
            兄弟组件间: 必须借助父组件(麻烦) B->A->C,A是父组件，B,C是子组件，数据data定义在A中，A给B传函数属性，B调用把数据交给A，A再把数据属性传给C
        
        传： <Blog v-for="(blog, index) in blogs" :key="blog.id" :blog="blog"/> 
        声明： props: ['blog'] 
        模板页面： <h2>{{blog.id}}---{{blog.title}}</h2>
         模板页面（template）中获取数据读取组件对象的对应属性值 ==》接收的所有属性都自动成为组件对象的属性，例：接收的是blog，不用写this.blog,直接写blog

    2). vue自定义事件===》相当于函数类型的props
          原生DOM事件： 绑定事件监听 / 触发事件
          父组件：绑定事件监听需要指定：事件名，回调函数(事件分发时，与数据匹配的回调函数调用，作用：处理事件，)，
          子组件：触发事件需要指定：事件名，数据(回调函数调用时接收了什么数据)；数据交给事件监听的回调函数
          数据就是：分发的event对象

          分发事件后，与数据匹配的回调函数调用，

    绑定事件监听：父组件
    1、【
         <Header @addTodo='addTodo'/>  // 指定子定义的方法
       】
    2、【  <Header ref="header"/>     
     // 给<Header />绑定事件监听：在子组件中找到标志对象
     this.$refs.header.$on('addTodo',this.addTodo)
     】
    分发事件：子组件
      this.$emit('addTodo', todo)
    
    绑定事件监听和分发事件的组件对象必须是同一个组件对象
    子向父通信：子的内部有自己的对象this，父有子的标签，可以找到子的对象，但是兄弟间找不到同一个对象。

        给子组件标签绑定事件监听
        子组件向父组件的通信方式
        功能类似于function props
        不适合隔层组件和兄弟组件间的通信

    3). 全局事件总线 -->任意组件间都可以通信 ===》是事件总线的原因（特点）：有绑定监听和分发事件，
    所有组件对象的原型对象都是一个vm
    
概念：创建一个全局的用于绑定事件监听和分发事件的对象: Global Event Bus (全局事件总线) 
作用：挂监听，分发事件
作用：事件总线对象就是一个vm，将其挂载到Vue的原型对象上, 所有的组件对象就都可以看到这个事件总线对象
看的见的原因：所有组件对象的原型对象是一个vm对象  ==> Vue原型对象是组件对象的原型链上的对象
        
        利用vm对象的$on()/$emit()/$off()
        利用vm对象是组件对象的原型对象
        创建vm对象作为全局事件总线对象保存到Vue的原型对象上, 所有的组件对象都可以直接可见:
            Vue.prototype.$bus = new Vue()
            任意组件A可以通过this.$bus.$on()绑定监听接收数据
            任意组件B可以通过this.$bus.$emit()分发事件, 传递数据

三大部分：事件总线的特点，能干啥，自定义
    4). slot
        父组件向子组件通信
        通信是带数据的标签结构
        注意: 标签是在父组件中解析
    使用场景：一个组件被复用多次，且内部的某一部分有多次不同的结构变化 
    一个slot就是一个占位
    传递的内容写在标签体里，组件内声明插槽接收

    5). vuex
        多组件共享状态(数据的管理)
        组件间的关系也没有限制
        功能比事件总线强大, 更适用于vue项目